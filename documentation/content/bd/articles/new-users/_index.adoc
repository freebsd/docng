---
title: ইউনিক্স ও FreeBSD'র হাতেখড়ি
authors:
  - author: অ্যানেলিস এন্ডারসন
    email: andrsn@andrsn.stanford.edu
releaseinfo: "$FreeBSD: head/bn_BD.UTF-8/articles/new-users/article.xml 43184 2013-11-13 07:52:45Z hrs $" 
trademarks: ["freebsd", "ibm", "microsoft", "opengroup", "general"]
---

= ইউনিক্স ও FreeBSD'র হাতেখড়ি
:doctype: article
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:source-highlighter: rouge
:experimental:
:figure-caption: Figure

[.abstract-title]
Abstract

`FreeBSD` ইনস্টল করতে পারায় আপনাকে _স্যালুট!!!_ বিভিন্ন ইউনিক্স এবং বিশেষ করে FreeBSD'র জগতে যারা নতুন, তাদেরকে উদ্দেশ্য করেই এই লেখা; তাই ইউনিক্সের প্রাথমিক ব্যাপারগুলো দিয়েই লেখাটি শুরু হয়েছে। আমরা ধরে নিচ্ছি যে, আপনি BSDi বা http://www.FreeBSD.org/[FreeBSD.org] এর সরবরাহকৃত FreeBSD'র ২.০.৫ বা তার পরবর্তী কোন সংস্করণ ব্যবহার করছেন; তাছাড়া আপনিই এমুহূর্তে আপনার সিস্টেমের একমাত্র ব্যবহারকারী এবং `ডস`/`উইন্ডোস` বা OS/2 ব্যবহারেও আপনি মোটামুটি অভ্যস্ত।

'''

toc::[]

[.title]
== লগ ইন ও লগ আউট

যখন `login:` লেখাটি দেখতে পাবেন, তখন `root` অথবা সাধারণ একজন ব্যবহারকারীরূপে লগ ইন করুন, অর্থাত্‍ সিস্টেমে প্রবেশ করুন। সাধারণ ব্যবহারকারির এই অ্যাকাউন্টটি পূর্বেই ইনস্টলেশনের সময় অথবা root হিসেবে তৈরী করে রাখতে হবে। root নামক অ্যাকাউন্টটি FreeBSD ইনস্টলেশনের সময় নিজে থেকেই তৈরী হয়। এই root অ্যাকাউন্টটির ক্ষমতা অপরিসীম। এটি থেকে সিস্টেমের যেকোন স্থানে প্রবেশ করে যেকোন পরিবর্তন করা যায়; এমনকি প্রয়োজনীয় ফাইল মুছে ফেলাও root এর জন্য কোন সমস্যা নয়। তাই root অ্যাকাউন্টে লগ ইন করলে যথেষ্ট সতর্কতা অবলম্বন করা প্রয়োজন। `%` এবং `#` চিহ্নদুটি কমান্ড প্রম্পট নির্দশ করে। কমান্ড প্রম্পট হল ব্যবহারকারীর নিকট থেকে বিভিন্ন কমান্ড বা নির্দেশ গ্রহন করার একটি বিশেষ প্রোগ্রাম। এই লেখায়, সাধারণ একজন ব্যবহারকারীর নিকট উপস্থাপিত কমান্ড প্রম্পট বোঝাতে `%` এবং root এর জন্য `#` ব্যবহৃত হয়েছে। আপনি যে কমান্ড প্রম্পটটি ব্যবহার করেন, তা এর থেকে ভিন্ন হতে পারে। 

লগ আউট করে প্রতিবার নতুন একটি `login:` প্রম্পট পেতে হলে লিখুন -

[source,bash]
....
# exit
....

এটিসহ অন্যান্য প্রতিটি কমান্ড লিখে kbd:[Enter] চাপুন। তাছাড়া একথাও মনে রাখবেন যে, ইউনিক্স ছোট ও বড় হাতের অক্ষরকে ভিন্নভাবে বিবেচনা করে, অর্থাত্‍ `exit` ও `EXIT` কখনোই এক নয়। 

কম্পিউটার বন্ধ (shut down) করতে চাইলে লিখুন -

[source,bash]
....
# /sbin/shutdown -h now
....

আর রিবুট করতে চাইলে লিখুন -

[source,bash]
....
# /sbin/shutdown -r now
....

অথবা

[source,bash]
....
# /sbin/reboot
....

একত্রে kbd:[Ctrl+Alt+Delete] চেপেও রিবুট করতে পারেন। রিবুটের পূর্বে FreeBSD কিছুটা সময় নেবে। FreeBSD'র নতুন সংস্করণগুলোতে `/sbin/reboot` ও kbd:[Ctrl+Alt+Delete] একই ফল দেয়। রিস্টার্ট বাটন চেপে কম্পিউটার রিবুট করা অপেক্ষা এদুটি অনেক ভাল উপায়। তাছাড়া নতুন করে FreeBSD ইনস্টলের ঝুকি এড়ানোর জন্যও এই দুটি পদ্ধতি ব্যবহার করা উচিত্‍।

[.title]
== Root হিসেবে নতুন ব্যবহারকারীর জন্য অ্যাকাউন্ট তৈরী

ইনস্টলেশনের সময় যদি কোন অ্যাকাউন্ট তৈরী করে না থাকেন এবং এখন root হিসেবে লগ ইন করে থাকেন, তবে একটি অ্যাকাউন্ট তৈরীর সময় হয়েছে। এজন্য লিখুন -

[source,bash]
....
# adduser
....

প্রথমবার এই কমান্ডটি ব্যবহার করলে কিছু প্রশ্ন করা হয় এবং কোন পছন্দ না থাকলে ডিফল্ট হিসেবে কি গ্ড়গ্রহন করা হবে তাও দেখানো হয়। ডিফল্ট শেল হিসেবে হয়তো sh এর নাম দেখানো হবে কিন্তু আপনি csh শেলও পছন্দ করতে পারেন। কিছুই পছন্দ করার না থাকলে শুধু kbd:[Enter] চাপুন। এই পছন্দগুলোই পরবর্তী প্রতিটি অ্যাকাউন্ট তৈরীর সময় ব্যবহৃত হবে। [.filename]#/etc/adduser.conf# নামক একটি পরিবর্তনযোগ্য ফাইলে এই তথ্যগুলো লেখা হয়।

নতুন কোন ব্যবহারকারীর জন্য অ্যাকাউন্ট তৈরীর একটি উদাহরণ এখন দেয়া হচ্ছে যেখানে _জ্যাক বেনিম্বলের জন্য জ্যাক_ নামে একটি অ্যাকাউন্ট তৈরী করা হয়। নিরাপত্তার ব্যাপারটি বেশ গুরুত্বপূর্ণ হলে জ্যাককে একটি পাসওয়ার্ডও দিতে হবে। জ্যাককে অন্যকোন গ্রুপের অন্তর্ভুক্ত করা হবে কিনা জানতে চাইলে লিখুন `wheel`

[source,bash]
....
Login group is "jack". Invite jack into other groups: wheel
....

এর ফলে _jack_ অ্যাকাউন্টে লগ ইন করেও `su` কমান্ড ব্যবহার করে root হওয়া যাবে। এভাবে root অ্যাকাউন্টে লগ ইন করলে অন্য কারো বিরক্তি উত্‍পাদনেরও কোন সম্ভাবনা নেই।

যেকোন সময় kbd:[Ctrl+C] চেপে `adduser` থেকে বের হয়ে আসা যায়। বের হওয়ার পূর্বে নতুন অ্যাকাউন্ট তৈরী হবে কি হবে না তা নিশ্চিত করার জন্য একটি সুযোগ দেয়া হবে; নতুন অ্যাকাউন্ট তৈরী করতে না চাইলে শুধু kbd:[n] চেপে না করে দেয়া যাবে। ইচ্ছা হলে _jill_ নামে দ্বিতীয় আরেকটি অ্যাকাউন্ট তৈরী করতে পারেন। এর সুবিধা হল - কোন কারণে _jack_ নামের অ্যাকাউন্টটি ক্ষতিগ্রস্থ হলে _jill_ নামের অ্যাকাউন্টটি ব্যবহার করতে পারবেন।

জ্যাকের জন্য নতুন অ্যাকাউন্ট তৈরী হয়ে গেলে `exit` কমান্ড ব্যবহার করে বের হয়ে আসুন ও জ্যাক হিসেবে পুনরায় লগ ইন করুন। বিশেষ দরকার না হলে root হিসেবে কাজ না করাই ভাল; এতে root এর শক্তি অপব্যবহার হওয়ার ঝুকি থাকে না।

যদি আপনি ইতিপূর্বেই জ্যাকের জন্য একটি অ্যাকাউন্ট তৈরী করে থাকেন এবং এখন তাকে শুধু `su` কমান্ড ব্যবহার করে root হওয়ার সুযোগ দিতে চান, তবে আপনি নিজে root হিসেবে লগ ইন করে [.filename]#/etc/group# ফাইলের প্রথম লাইনে _jack_ শব্দটি যোগ করুন। এই লাইনটিতে `wheel` গ্রুপের সদস্যদের নাম তালিকাভুক্ত থাকে। তবে এর পূর্বে আপনাকে Vi টেক্সট এডিটর কিংবা Vi এর পরিবর্তে ee ব্যবহার করা শিখতে হবে। Vi থেকে ee ব্যবহার করা অপেক্ষাকৃত সহজ। সাধারণত FreeBSD'র নতুন সংস্করণগুলোতে ee দেয়া থাকে।

কোন ব্যবহারকারীর অ্যাকাউন্ট মুছে ফেলতে চাইলে `rmuser` কমান্ড ব্যবহার করুন।

[.title]
== ঘুরে দেখা

একজন সাধারণ ব্যবহারকারীরূপে লগ ইন করুন এবং বিভিন্ন ডিরেক্টরি ঘুরে ফিরে দেখুন। প্রয়োজনীয় সহায়িকা ও FreeBSD সংক্রান্ত বিভিন্ন তথ্য জানার জন্য কিছু কমান্ড ব্যবহার করে দেখতে পারেন।

এখানে কয়েকটি কমান্ড ও তাদের কার্যকারিতা উল্লেখ করা হলঃ

`id`::
আপনার অ্যাকাউন্ট, গ্রুপ ইত্যাদির নাম জানাবে।

`pwd`::
এ মুহূর্ত কোন ডিরেক্টরিতে অবস্থান করছেন তা জানাবে।

`ls`::
বর্তমান ডিরেক্টরির সকল ফাইলের নাম দেখাবে।

`ls -F`::
ফাইলের নাম দেখানোর সময় এক্সিকিউটেবল বা বাইনারি ফাইলের শেষে `*`, ডিরেক্টরির শেষে `/` এবং সিম্বলিক লিঙ্কের শেষে `@` জুড়ে দেবে।

`ls -l`::
নামসহ প্রতিটি ফাইলের বিভিন্ন তথ্য এই ক্রমানুসারে দেখাবে - আকার, তারিখ ও ব্যবহারের অনুমতি।

`ls -a`::
লুক্কায়িত "dot" ফাইলসহ সব ফাইলের নামই দেখাবে। root হিসাবে লগ ইন করলে অবশ্য -a ছাড়াই লুক্কায়িত ফাইলের নাম দেখা যায়।

`cd`::
ডিরেক্টরি পরিবর্তন করে। cd .. লিখলে একধাপ উপরের ডিরেক্টরিতে যাওয়া যায়। cd'র পর যে একঘর space আছে, তা অবশ্যই লিখতে হবে। /usr/local/ ডিরেক্টরিতে যেতে চাইলে লিখুন cd /usr/local । cd ~ লিখলে যে অ্যাকাউন্টে লগ ইন করেছেন তার home ডিরেক্টরিতে প্রবেশ করবেন। জ্যাক অ্যাকাউন্টের হোম ডিরেক্টরি হল /usr/home/jack। /cdrom এ cd কমান্ড ব্যবহার করে প্রবেশ করুন এবং ls ব্যবহার করে দেখুন যে কোন সিডিরম মাউন্ট করা আছে কিনা এবং থাকলে তা কাজ করছে কিনা।

`view filename`::
কোন পরিবর্তন না করে একটি ফাইল পড়তে দেয়। view /etc/fstab লিখে একবার পরীক্ষা করে দেখুন। পড়া শেষ হলে q চেপে বের হয়ে আসুন।

`cat filename`::
কম্পিউটার স্ক্রীনে _filename_ নামের ফাইলটিকে প্রিন্ট করে। যদি ফাইলটি খুব বড় হয় এবং স্ক্রীনে শুধুমাত্র ফাইলের শেষাংশই দেখা যায় তবে kbd:[Scroll Lock] চেপে kbd:[up-arrow] চাপলে ফাইলের অন্যান্য অংশও পড়তে পারবেন। এই একই প্রক্রিয়া ম্যানুয়াল পেজের ক্ষেত্রেও প্রযোজ্য। পুনর্বার kbd:[Scroll Lock] চাপলে এই প্রক্রিয়া বন্ধ হয়ে যাবে। আপনার home ডিরেক্টরির কিছু লুকানো ফাইলের ওপর `cat` কমান্ডটি ব্যবহার করে দেখতে পারেন, যেমন - `cat .cshrc`, `cat .login`, `cat .profile`।

[.filename]#.cshrc# ফাইলে `ls` কমান্ডের কিছু alias দেখতে পাবেন। আপনি নিজেও [.filename]#.cshrc# ফাইলে কিছু alias তৈরী করতে পারেন। যদি সিস্টেমের প্রত্যেক ব্যবহারকারীকে alias'গুলো ব্যবহার করতে দিতে চান, তবে csh এর মূল কনফিগারেশন ফাইল [.filename]#/etc/csh.cshrc#'তে আপনার alias গুলো লিখে রাখুন।

[.title]
== তথ্য ও সহায়িকা

এখন সহায়িকা পড়ার বিভিন্ন পদ্ধতির বর্ণনা দেয়া হচ্ছে। "text" শব্দটির সাহায্য আপনার পছন্দের কোন একটি বিষয়কে বোঝানো হচ্ছে। সাধারণত বিভিন্ন কমান্ড ও গুরুত্বপূর্ণ ফাইলের জন্য প্রয়োজনীয় সহায়িকা দেয়া থাকে।

`apropos text`::
`whatis` ডাটাবেসে _text_ এর ওপর কোন তথ্য থাকলে তা দেখায়।

`man text`::
_text_ সংক্রান্ত ম্যানুয়াল পেজ থাকলে তা দেখায়। ম্যানুয়াল পেজ হল ইউনিক্স সিস্টেমগুলোতে ডকুমেন্টেশনের সবচেয়ে বড় উত্‍স। উদাহরণস্বরূপ `man ls` কমান্ডটি আপনাকে `ls` কমান্ড ব্যবহারের সমস্ত পদ্ধতি জানাবে। ম্যানুয়াল পেজ দেখার সময় kbd:[Enter] চাপলে একলাইন সামনে, kbd:[Ctrl+B] চাপলে এক স্ক্রীন পেছনে, kbd:[Ctrl+F] চাপলে এক স্ক্রীন সামনে এবং kbd:[q] বা kbd:[Ctrl+C] চাপলে ম্যানপেজ থেকে বের হয়ে আসা যায়।

`which text`::
আপনার ব্যবহৃত path এ _text_ কমান্ডটি পাওয়া গেলে path টি জানানো হয়।

`locate text`::
যে সকল path এ _text_ শব্দটি পাওয়া যাবে, তা আপনাকে জানানো হবে।

`whatis text`::
সংক্ষিপ্তাকারে _text_ কমান্ডটির কাজ সম্পর্কে জানায়। `whatis *` লিখলে বর্তমান ডিরেক্টরির সকল বাইনারি ফাইলের কাজ সম্পর্কে জানাতে চেষ্টা করে ।

`whereis text`::
_text_ নামক ফাইলটিকে খুজে বের করার চেষ্টা করে এবং খুজে পেলে _ text_ ফাইলের path জানায়।

কিছু বহুল ব্যবহৃত ও গুরুত্বপুর্ণ কমান্ডের ওপর `whatis` ব্ঃব্যবহার করে দেখতে পারেন, যেমন- `cat`, `more`, `grep`, `mv`, `find`, `tar`, `chmod`, `date` এবং `script` । `more` কমান্ডটি এক পৃষ্ঠা করে লেখা পড়তে দেয়। ডস-এও কমান্ডটি একই কাজ করে; উদাহরণস্বরূপ: `ls -l | more` কিংবা `more filename` । ``*`` চিহ্নটি wildcard হিসেবে কাজ করে, যেমন- `ls w*` লিখলে নামের প্রথম অক্ষর w, এ ধরনের সব ফাইলের নাম দেখা যায়।

হয়তো কিছু কমান্ড আপনার সিস্টেমে ভালভাবে কাজ করছে না। `locate` এবং `whatis` উভয়ই একটি ডাটাবেসের ওপর নির্ভর করে যা প্রতি সপ্তাহে নতুন করে তৈরী করা হয়। যদি আপনার কম্পিউটারটি সাপ্তাহিক ছুটির দিনে বন্ধ থাকে কিংবা ঐ দিন FreeBSD চালানো না হয়, তবে দৈনিক, সাপ্তাহিক কিংবা মাসিক কাজগুলো যেকোন সময়ই করতে পারেন। পরবর্তি কমান্ডগুলো আপনাকে এই ব্যবস্থা করে দেবে; root হিসেবে কমান্ডগুলো চালান এবং একটি কমান্ডের কাজ শেষ হলেই কেবল পরের কমান্ডটি প্রয়োগ করুন।

[source,bash]
....
# periodic daily
সংশ্লিষ্ট আউটপুট
# periodic weekly
সংশ্লিষ্ট আউটপুট
# periodic monthly
সংশ্লিষ্ট আউটপুট
....

এই কমান্ডগুলো চলার সময় বসে থেকে অপেক্ষা করতে না চাইলে kbd:[Alt+F2] চেপে আরেকটি _ভার্চুয়াল কনসোল_ খুলে তাতে লগ ইন করুন। মনে রাখবেন, ইউনিক্স একটি মাল্টিটাস্কিং, মাল্টিইউজার সিস্টেম, তাই একত্রে অসংখ্য ব্যবহারকারী ও প্রোগ্রাম চলানো কোন সমস্যা নয়। নতুন কনসোল চালু করলেও অবশ্য কমান্ডগুলো আপনার বর্তমান কনসোলে কিছু লেখা দেখাবে; `clear` কমান্ড ব্যবহার করে খুব সহজেই স্ক্রীন পরিস্কার করতে পারেন। কমান্ডগুলোর কাজ শেষ হয়ে গেলে [.filename]#/var/mail/root# এবং [.filename]#/var/log/messages# ফাইলদুটোতে একবার চোখ বুলিয়ে দেখুন।

সিস্টেম অ্যাডমিনস্ট্রেশনের অংশ হিসেবে প্রায়ই এধরনের কমান্ড চালাবার প্রয়োজন হয়। যেহেতু আপনার ইউনিক্স সিস্টেমটির আপনিই একমাত্র ব্যবহারকারী, তাই সিস্টেম অ্যাডমিনস্ট্রেরের ভূমিকাও আপনাকেই পালন করতে হবে। সাধারণত যে কাজগুলো root হিসেবে না করলেই নয়, সেগুলোই সিস্টেম অ্যাডমিনস্ট্রেশনের অংশ। বাজারে ইউনিক্স সিস্টেম অ্যাডমিনস্ট্রেশনের ওপর অনেক মোটা মোটা বই পাওয়া গেলেও সিস্টেম অ্যাডমিনস্ট্রেশনের ভাল বর্ণনা এসব বইয়ের অধিকাংশতেই থাকে না। বরং এদের একটা বড় অংশ ব্যায় হয় উইন্ডো ম্যানেজারের ব্যবহার পদ্ধতি সংক্রান্ত বর্ণনা দিয়েই। ইউনিক্স সিস্টেম অ্যাডমিনস্ট্রেশনের ওপর দুটি অসাধারণ বই হল এডি নেমেথে র লেখা Unix System Administration Handbook (Prentice-Hall, 1995, ISBN 0-13-15051-7) (যার দ্বিতীয় সংস্করণের প্রচ্ছদ লাল রঙের) এবং এলিন ফ্রিজে র লেখা Essential System Administration (O'Reilly Associates, 1993, ISBN 0-937175-80-3)। আমি নিজে অবশ্য পড়ি নেমেথের বই।

[.title]
== লেখা এডিট করা

সিস্টেমকে প্রয়োজন মত কনফিগার করার জন্য আপনাকে বিভিন্ন ফাইল এডিট করতে হবে। এই ফাইলগুলোর অধিকাংশই [.filename]#/etc# ডিরেক্টরিতে অবস্থিত এবং এদেরকে root হিসেবে এডিট করতে হয়; root হওয়ার জন্য `su` কমান্ডটি ব্যবহার করতে পারেন। সহজে চালানো যায় এরকম একটি এডিটর হল `ee`; কিন্তু দূরদর্শী চিন্তাভাবনা করলে `vi` এডিটরই চালাতে শেখা উচিত্‍। `vi` ইনস্টল করা থাকলে `vi` এর ওপর একটি চমত্‍কার টিউটোরিয়াল পাবেন এখানে- [.filename]#/usr/src/contrib/nvi/docs/tutorial# । এছাড়াও এটি পেতে পারেন link:ftp.cdrom.com[ftp.cdrom.com] নামক FTP সাইটের link:ftp.cdrom.com/FreeBSD/FreeBSD-current/src/contrib/nvi/docs/tutorial/[FreeBSD/FreeBSD-current/src/contrib/nvi/docs/tutorial] অবস্থান থেকে।

এডিট করার পূর্বে প্রতিটি ফাইলের একটি ব্যাকআপ কপি রাখা উচিত্‍। যদি আপনি [.filename]#/etc/rc.conf# ফাইলটি এডিট করতে চান তবে `cd /etc` লিখে [.filename]#/etc# ডিরেক্টরিতে প্রবেশ করুন এবং লিখুন

[source,bash]
....
# cp rc.conf rc.conf.orig
....

এর ফলে [.filename]#rc.conf# ফাইলের [.filename]#rc.conf.orig# নামক একটি কপি তৈরী হবে। পরে যদি কোন কারণে [.filename]#rc.conf# এর মূল কপি ব্যবহারের প্রয়োজন হয় তবে [.filename]#rc.conf.orig# কে [.filename]#rc.conf# এ কপি করা যাবে। তবে সবচেয়ে ভাল হয় [.filename]#rc.conf# এর নাম পরিবর্তন করে [.filename]#rc.conf.orig# করার পর [.filename]#rc.conf.orig# কে [.filename]#rc.conf# এ কপি করলে:

[source,bash]
....
# mv rc.conf rc.conf.orig
# cp rc.conf.orig rc.conf
....

এরকম করার কারণ হল, `mv` কমান্ডের সাহায্যে ফাইলের নাম পরির্বতন করলেও ফাইল সংক্রান্ত বিভিন্ন তথ্য, যেমন- তারিখ, মালিকানা ইত্যাদি অপরিবর্তিত থাকে। এখন [.filename]#rc.conf# কে এডিট করতে পারেন। কোন কারণে এডিটপূর্ব [.filename]#rc.conf# এর প্রয়োজন হলে প্রথমে বর্তমান [.filename]#rc.conf# এর নাম পরিবর্তন করে [.filename]#rc.conf.myedit# করুন (কারণ আপনার এডিটকৃত [.filename]#rc.conf#'কেও হয়তো ভবিষ্যতে প্রয়োজন হতে পারে) ঃ

[source,bash]
....
# mv rc.conf.orig rc.conf
....

এর ফলে সবকিছু পূর্বের মত হয়ে যাবে।

কোন ফাইল এডিট করতে চাইলে লিখুন,

[source,bash]
....
# vi filename
....

kbd:[Arrow] key ব্যবহার করে ফাইলের আগে ও পিছে যেতে পারবেন। kbd:[ESC] চাপলে `vi` তার কমান্ড মোডে প্রবেশ করে। এখানে `vi` এর নিজস্ব কিছু কমান্ডের বর্ণনা দেয়া হলঃ

x::
যে অক্ষরটির ওপর কার্সর অবস্থান করছে তা মুছে ফেলে।

dd::
সম্পূর্ণ একটি লাইন মুছে ফেলে(একটি প্রকৃত লাইন স্ক্রীনের একাধিক লাইন জুড়ে থাকতে পারে; সেজন্য এ কমান্ডটি লিখলে একটি প্রকৃত লাইনের জন্য স্ক্রীনে দৃশ্যমান সবগুলো লাইনই মুছে যাবে)।

i::
কার্সরের অবস্থানে লেখা ঢুকাতে দেয়।

a::
কার্সর পরবর্তী অবস্থানে লেখা ঢুকাতে দেয়।

kbd:[a] বা kbd:[i] চাপার পর আপনি ফাইলে লিখতে পারবেন এবং kbd:[ESC] চেপে আবারো কমান্ড মোডে প্রবেশ করতে পারবেন। কমান্ডমোডের আরো কিছু কমান্ড দেয়া হল,

:w::
আপনার করা পরিবর্তনগুলো ডিস্কে সেভ হয় ও তারপর আবার ফাইল এডিট করা যায়।

:wq::
ফাইল সেভ হয় ও `vi` থেকে বের হয়ে আসে।

:q!::
কোন পরিবর্তন সেভ না করেই `vi` থেকে বের হয়ে আসে।

/text::
_text_ কে খুজে বের করে ও কার্সরকে সেখানে নিয়ে যায়। এরপর kbd:[/] ও kbd:[Enter] চাপলে পরবর্তী _text_ এর পূর্বে কার্সর নিয়ে যায়।

G::
ফাইলের শেষে যায়।

nG::
nতম লাইনে যায়।

Ctrl-L::
স্ক্রীনে সবকিছু নতুন করে লেখা হয়।

kbd:[Ctrl+b] এবং kbd:[Ctrl+f]::
যথাক্রমে একস্ক্রীন সামনে ও পেছনে যায়। `more` ও `view` কমান্ডের ক্ষেত্রেও এরা অনুরূপ কাজ করে।

আপনার home ডিরেক্টরিতে `vi` চালিয়ে অভ্যাস করুন। `vi filename` লিখে একটি নতুন ফাইল খুলুন, কয়েকটি লাইন লিখুন, মুছে ফেলুন, সেভ করুন, `vi` থেকে বের হয়ে যান, আবার নতুন ফাইলটি `vi`-এ ওপেন করুন। এডিটর হিসেবে `vi` আসলেই কিছুটা জটিল এবং একারণে অনেক কিছুই আপনার কাছে অদ্ভূত মনে হতে পারে। কখনো হয়তো ভুল কমান্ডের কারণে `vi` এমন কিছু করে বসবে যা আপনি মোটেও করতে চাচ্ছেন না। এতকিছুর পরও `vi` অনেকেরই পছন্দের এডিটর; DOS EDIT থেকে এটি অনেক শক্তিশালী, `:r` কমান্ডটি ব্যবহার করে এসম্পর্কে কিছু ধারনা পেতে পারেন। একবার দুবার kbd:[ESC] চেপে নিশ্চিত হয়ে নিন যে আপনি `vi` এর কমান্ড মোডে আছেন। তারপর `:w` চেপে লেখা সেভ করুন, কিছু লিখে `:q!` চেপে সেভ না করেই বের হয়ে আসুন এবং নতুন করে ফাইলটি খুলে সর্বশেষ সেভ করা অবস্থা থেকে আবারও এডিট করতে থাকুন।

এখন `cd` কমান্ডের সাহায্যে [.filename]#/etc# ডিরেক্টরিতে প্রবেশ করুন, `su` কমান্ড ব্যবহার করে root হোন, `vi` দিয়ে [.filename]#/etc/groups# ফাইলটি এডিট করে `whell` গ্রুপে কোন একজন ব্যবহারকারীকে যোগ করুন। এজন্য প্রথম লাইনটির শেষে একটি কমা এবং তারপর উক্ত ব্যবহারকারীর লগ ইনের নাম লিখুন। এরপর প্রথমে kbd:[Esc] ও পরে `:wq` চেপে ফাইলটি সেভ করুন ও `vi` থেকে বের হয়ে আসুন। এই পরিবর্তন তাত্‍ক্ষণিকভাবে কার্যকর হবে। (আশা করি কমার পর কোন space বসাননি)

[.title]
== ডস থেকে ফাইল প্রিন্ট করা

এ অবস্থায় সম্ভবত আপনার প্রিন্টার কাজ করছে না। তাই কোন ম্যানুয়াল পেজকে ফ্লপিতে করে ডস-এ নিয়ে কিভাবে প্রিন্ট করবেন তার বর্ণনা এখানে দেয়া হল। মনে করুন আপনি কোন ফাইল ব্যবহারের অনুমতি পরিবর্তনের প্রক্রিয়া ভালভাবে পড়তে চাইছেন (এটি যথেষ্ট গুরুত্বপূর্ণ একটি ব্যাপার)। `man chmod` কমান্ড ব্যবহার করে আপনি এসম্পর্কে পড়তে পারবেন,

[source,bash]
....
% man chmod | col -b > chmod.txt
....

এই কমান্ডটি `chmod` এর ম্যানুয়াল পেজকে স্ক্রীনে না দেখিয়ে [.filename]#chmod.txt# ফাইলে লিখে দেবে। এখন ফ্লপি ড্রাইভে একটি ডস ফরম্যাটের ফ্লপি রাখুন, `su` কমান্ড ব্যবহার করে root হোন এবং লিখুন


[source,bash]
....
# /sbin/mount -t msdos /dev/fd0 /mnt
....

এর ফলে [.filename]#/mnt# ডিরেক্টরিতে ফ্লপি ড্রাইভ মাউন্ট হবে।

এখন যে ডিরেক্টরিতে [.filename]#chmod.txt# নামের ফাইলটি তৈরী করেছেন সেখানে গিয়ে [.filename]#chmod.txt# কে ফ্লপিতে কপি করতে পারেন (এজন্য root হিসেবে কাজ করার কোন প্রয়োজন নেই, তাই `exit` লিখে অনায়াসে `jack` হিসেবে কাজকর্ম চালিয়ে যেতে পারেন)।

[source,bash]
....
% cp chmod.txt /mnt
....

`ls /mnt` কমান্ড লিখলে [.filename]#/mnt# ডিরেক্টরির সব ফাইলের নাম দেখতে পাবেন এবং সেখানে [.filename]#chmod.txt# এর নামও থাকবে।

আপনি বিশেষ করে [.filename]#/sbin/dmesg# কমান্ডের আউটপুটকে একটি ফাইলে লিখে রাখার প্রয়োজনীয়তা অনুভব করতে পারেনঃ

[source,bash]
....
% /sbin/dmesg > dmesg.txt
....

তৈরী হয়ে গেলে ফাইলটিকে ফ্লপিতে স্থানান্তর করতে পারেন। [.filename]#/sbin/dmesg# আউটপুট হিসেবে বুটলগ রেকর্ড দেখায় এবং এটি বিশেষভাবে গুরুত্বপূর্ণ কারণ এর মাধ্যমে জানা যায় যে FreeBSD চালু হওয়ার সময় কি কি যন্ত্রপাতি সনাক্ত করেছে। যদি আপনি FreeBSD Generals Questions মেইলিং লিস্ট mailto:freebsd-questions@FreeBSD.org[freebsd-questions@FreeBSD.org] কিংবা কোন ইউজনেট গ্রুপে এধরনের কোন প্রশ্ন করেন যে, "FreeBSD আমার কম্পিউটারের টেপড্রাইভ খুজে পাচ্ছে না, এখন আমি কি করব ?" তবে উত্তরদাতাদের প্রত্যেকেই `dmesg` কি দেখাচ্ছে তা জানতে চাইবে।

এখন আপনি root হিসেবে ফ্লপিড্রাইভকে ডিসমাউন্ট করতে পারেন,

[source,bash]
....
# /sbin/umount /mnt
....

এবার ফ্লপি ডিস্কটি বের করে কম্পিউটার রিবুট করুন ও তারপর ডস-এ প্রবেশ করুন। এই ফাইলগুলোকে ফ্লপি থেকে কোন একটি ডস ডিরেক্টরিতে কপি করে ডস-এর EDIT, উইন্ডোসের নোটপ্যাড, ওয়ার্ডপ্যাড বা অন্য কোন ওয়ার্ডপ্রসেসরে ওপেন করুন এবং ছোটখাট কোন পরিবর্তন করুন যেন ফাইলটিকে নতুন করে সেভ করার সুযোগ পাওয়া যায়। এরপর ফাইলটি প্রিন্ট করুন। আশা করা যায় যে এই পদ্ধতিতে ফাইলটি ঠিক মতই প্রিন্ট হবে। সবচেয়ে ভাল ফল পাওয়ার জন্য ডস-এর `print` কমান্ড ব্যবহার করে ম্যানুয়াল পেজকে প্রিন্ট করতে পারেন। (এ মুহূর্তে FreeBSD থেকে মাউন্টকৃত কোন ডস পার্টিশনে সরাসরি ফাইল কপি করাটা কিছুটা ঝুকিপূর্ণ)

FreeBSD থেকে প্রিন্ট করার জন্য [.filename]#/etc/printcap# ফাইলে একটি এন্ট্রি থাকতে হবে এবং [.filename]#/var/spool/output# ডিরেক্টরিতে এই এন্ট্রির নামানুসারে একটি ডিরেক্টরি থাকতে হবে। যদি আপনার প্রিন্টারটি  পোর্টে (যাকে ডস-এ  বলা হয়) থাকে এবং [.filename]#/var/spool/output# ডিরেক্টরিতে [.filename]#lpd# নামে কোন ডিরেক্টরি না থাকে তবে root হিসেবে `mkdir lpd` কমান্ড দিয়ে [.filename]#lpd# নামের ডিরেক্টরিটি তৈরী করলেই প্রিন্টারটি হয়তো কাজ করবে। প্রিন্টারটি FreeBSD'তে কাজের উপযোগী হলে সিস্টেম বুট হওয়ার সময় সাড়া দেবে এবং lp বা lpr একটি ফাইল প্রিন্ট করার চেষ্টা করবে। ফাইলটি শেষ পর্যন্ত প্রিন্ট হবে কি হবে না তা নির্ভর করে প্রয়োজনীয় প্রিন্টার কনফিগারেশনের ওপর। প্রিন্টার কনফিগার করার বিস্তারিত বিবরণ রয়েছে FreeBSD link:../../handbook/handbook.html[হ্যান্ডবুকে]।

[.title]
== আরো কিছু প্রয়োজনীয় কমান্ড

`df`::
মাউন্টকৃত সকল ফাইল সিস্টেমের আয়তন দেখায়।

`ps aux`::
চলন্ত প্রসেসগুলোর নাম ও অন্যান্য কিছু বৈশিষ্ট্য দেখায়। কমান্ডটির সংক্ষিপ্তরূপ হল ps ax ।

`rm filename`::
_filename_ নামের ফাইলটিকে মুছে ফেলে।

`rm -R dir`::
_dir_ নামের ডিরেক্টরি ও তার অন্তর্গত সকল সাবডিরেক্টরি মুছে ফেলে -- এই কমান্ডটি ব্যবহারের পূর্বে যথেষ্ট সতর্ক হওয়া প্রয়োজন।

`ls -R`::
বর্তমান ডিরেক্টরি ও তার বিভিন্ন সাবডিরেক্টরিতে অবস্থিত সকল ফাইলের নাম দেখায়। ফাইল খুজে বের করার কোন ভাল পদ্ধতি যখন আমার জানা ছিল না তখন আমি `ls -AFR > where.txt` কমান্ডটি ব্যবহার করে [.filename]#/# অথবা [.filename]#/usr# ডিরেক্টরির সব ফাইলের তালিকা তৈরী করে তাতে দরকারী ফাইলটি খুজতাম।

`passwd`::
কোন সাধারণ ব্যবহারকারী বা root এর পাসওয়ার্ড পরিবর্তন করে।

`man hier`::
ইউনিক্সে ব্যবহৃত ফাইল সিস্টেম বিন্যাসের ওপর লিখিত ম্যানুয়াল পেজ দেখায়।

`find` কমান্ড ব্যবহার করে [.filename]#/usr# ডিরেক্টরির কোন ফাইলকে এভাবে খুঁজে পেতে পারেন,

[source,bash]
....
# find /usr -name "filename"
....

আপনি ইচ্ছা করলে _filename_ এর পরিবর্তে ওয়াইল্ডকার্ড হিসেবে `*` ব্যবহার করতে পারেন (ফাইলের নাম লিখলে তার পূর্বে ও পরে উদ্ধৃতি চিহ্ন থাকবে)। যদি `find` কমান্ডকে [.filename]#/usr# এর পরিবর্তে [.filename]#/# ডিরেক্টরির নাম দেয়া হয় তবে সিডিরম ও ডস পার্টিশনসহ মাউন্টকৃত সকল ফাইল সিস্টেমেই ফাইলটি খোঁজা হবে।

ইউনিক্স কমান্ড ও ইউটিলিটির ওপর একটি চমত্‍কার বই হল, অ্যাব্রাহাম ও লারসেনের লেখা Unix for the Impatient (2nd ed., Addison-Wesley, 1996). এছাড়া ইন্টারনেটেও ইউনিক্স এর ওপর প্রচুর তথ্য পাওয়া যায়। এর মধ্যে বিশেষ উল্লেখযোগ্য হল http://www.eecs.nwu.edu/unix.html[Unix Reference Desk] ।

[.title]
== এখন যা করবেন

আপনি সম্ভবত এখন বিভিন্ন ডিরেক্টরিতে প্রবেশ করতে ও সেখানকার ফাইল এডিট করতে পারছেন। সুতরাং অন্যান্য কাজগুলোও আপনি এখন করতে পারবেন। এ সম্পর্কিত প্রচুর তথ্য FreeBSD হ্যান্ডবুক (যা সম্ভবত আপনার হার্ডডিস্কেই রয়েছে) ও FreeBSD'র ওয়েবসাইটে রয়েছে। বিভিন্ন কাজের জন্য অসংখ্য সফটওয়ারের প্যাকেজ ও পোর্ট সংস্করণ সিডিরম ও ওয়েবসাইট দুস্থানেই আছে। কিভাবে প্যাকেজ ও পোর্ট ইনস্টল করতে হবে সে সম্পর্কে হ্যান্ডবুকে বিস্তারিত বিবরণ দেয়া হয়েছে। কোন প্যাকেজ সিডিরমে থাকলে তা ইনস্টল করার সহজ পদ্ধতিহল `pkg_add /cdrom/packages/All/packagename`, এখানে _packagename_ শব্দটি দিয়ে যে সফটওয়ারটি ইনস্টল করা হচ্ছে তার প্যাকেজ ফাইলের নাম বোঝানো হয়েছে। সিডিরমের [.filename]#cdrom/packages/index#, [.filename]#cdrom/packages/index.txt# এবং [.filename]#cdrom/ports/index# ফাইলগুলোতে সব প্যাকেজ ও পোর্টের নাম ও অতি সংক্ষিপ্ত বর্ণনা রয়েছে। সফটওয়ারগুলোর সম্পূর্ণ বিবরণ থাকে [.filename]#/cdrom/ports/*/*/pkg/DESCR# ফাইলে। এখানে `*` দুটো যথাক্রমে সফটওয়ারের ধরন ও নামের পরিবর্তে ব্যবহৃত হচ্ছে।

সিডিরম থেকে পোর্ট ইনস্টল করার জন্য হ্যান্ডবুকে যে বর্ণনা রয়েছে তা যদি আপনার কাছে বেশ জটিল মনে হয় তবে এই সংক্ষিপ্ত বর্ণনাটি আপনার কাজে আসতে পারেঃ

যে পোর্টটি ইনস্টল করবেন তা প্রথমে খুজে বের করুন। মনে করুন পোর্টটির নাম Kermit। সিডিরমের ভেতর Kermit এর জন্য একটি ডিরেক্টরি থাকবে। এই ডিরেক্টরিকে [.filename]#/usr/local# ডিরেক্টরিতে কপি করুন ( যেসকল সফটওয়ার সিস্টেমের সকল ব্যবহারকারীই চালাবে সেগুলো ইনস্টল করার জন্য [.filename]#/usr/local# একটি ভাল জায়গা)ঃ

[source,bash]
....
# cp -R /cdrom/ports/comm/kermit  /usr/local
....

এর ফলে সিডিরমের kermit সাবডিরেক্টরির সব ফাইলই [.filename]#/usr/local/kermit# ডিরেক্টরিতে কপি হবে।

আপনার সিস্টেমে [.filename]#/usr/ports/distfiles# নামে কোন ডিরেক্টরি না থাকলে `mkdir` কমান্ডের সাহায্যে তা তৈরী করুন। এখন [.filename]#/cdrom/ports/distfiles# ডিরেক্টরিতে আপনার প্রয়োজনীয় পোর্ট ফাইলটি আছে কিনা তা দেখুন। যদি থাকে, তবে তা [.filename]#/usr/ports/distfiles# ডিরেক্টরিতে কপি করুন। FreeBSD'র নতুন সংস্করণগুলোতে অবশ্য এই কপি করার কাজটি স্বয়ংক্রিয়ভাবে হয় আর তাই আপনার ব্যবহৃত সংস্করণটি মোটামুটি নতুন হলে এই ধাপটি বাদ দিতে পারেন। জেনে রাখা ভাল যে, Kermit এর জন্য সিডিরমে কোন পোর্ট ফাইল থেকে না।

এখন `cd` কমান্ড ব্যবহার করে [.filename]#/usr/local/kermit# ডিরেক্টরিতে প্রবেশ করুন। এখানে [.filename]#Makefile# নামে একটি ফাইল থাকবে। এবার লিখুন, 

[source,bash]
....
# make all install
....

সিডিরম বা [.filename]#/usr/ports/distfiles# ডিরেক্টরিতে যদি প্রয়োজনীয় কম্প্রেসকৃত পোর্ট ফাইল না থাকে, তবে FTP ব্যবহার করে এসময় তা আনা হবে। যদি [.filename]#/usr/ports/distfiles# ডিরেক্টরিতে সংশ্লিষ্ট ফাইল না থাকে এবং নেটওয়ার্কও সচল না থাকে তবে অন্য কোন কম্পিউটার থেকে পোর্ট ফাইলটি ডাউনলোড করে ফ্লপিতে করে নিয়ে আসতে হবে অথবা আপনার কম্পিউটারের ডস পার্টিশনে প্রথমে কপি করে পরে তা [.filename]#/usr/ports/distfiles#-এ কপি করতে হবে। যদি ডস ব্যবহার করে পোর্ট ফাইলটি ডাউনলোড করতে চান তবে উক্ত পোর্টের [.filename]#Makefile# পড়ে (`cat`, `more` বা `view` কমান্ডের সাহায্যে) জেনে নিতে হবে যে কোন সাইট থেকে ফাইলটি ডাউনলোড করা যায়। ডস থেকে ডাউনলোড করা হলে ফাইলের নাম ছোট হয়ে যাবে। তাই [.filename]#/usr/ports/distfiles#-এ কপি করার পর ফাইলটিকে প্রকৃত নামে পরিবর্তন করতে হবে (`mv` কমান্ড ব্যবহার করে) যেন পরবর্তীতে তা মূল নামেই খুঁজে পাওয়া যায় (FTP ব্যবহার করতে চাইলে বাইনারি মোডে ডাউনলোড করুন)। এখন [.filename]#/usr/local/kermit#-এ প্রবেশ করে যে ডিরেক্টরিতে [.filename]#Makefile# আছে তা খুজে বের করুন এবং `make all install` কমান্ডটি প্রয়োগ করুন।

কোন পোর্ট বা প্যাকেজ ইনস্টল করার সময় আরেকটি ব্যাপার যা ঘটে তা হল সংশ্লিষ্ট সফটওয়ারটি ছাড়াও অন্যান্য এক বা একাধিক সফটওয়ার ইনস্টলেশনের প্রয়োজনীয়তা। যদি ইনস্টলেশন প্রক্রিয়াটি can't find unzip বা এধরনের কোন লেখা দেখিয়ে বন্ধ হয়ে যায়, তবে প্রথমে unzip এর প্যাকেজ বা পোর্ট ইনস্টল করে তারপর সংশ্লিষ্ট সফটওয়ারটি ইনস্টল করতে হবে।

ইনস্টলেশন সম্পন্ন হলে `rehash` কমান্ডটি ব্যবহার করুন। এর ফলে FreeBSD তার path এ অবস্থিত ফাইলগুলোর নাম নতুন করে জানতে পারবে। যদি `which` ও `whereis` কমান্ড চালালে ঘনঘন path not found দেখতে পান তবে home ডিরেক্টরির [.filename]#.cshrc# ফাইলে path এর অন্তর্গত ডিরেক্টরির তালিকাতে নতুন কিছু ডিরেক্টরির নাম যোগ করতে পারেন। ইউনিক্স ও ডস উভয়টিতেই path এর ভূমিকা অনুরূপ; বে ইউনিক্সে নিরাপত্তার খাতিরে বর্তমান ডিরেক্টরি নিজে থেকে path এর অন্তর্ভুক্ত হয় না। যদি বর্তমান ডিরেক্টরিতে অবস্থিত কোন কমান্ড ব্যবহার করতে চান, তবে কমান্ডের পূর্বে [.filename]#./# যোগ করতে হবে। এক্ষেত্রে লক্ষ্য রাখতে হবে যেন slash ও কমান্ডের মাঝে কোন space না থাকে।

আপনি ইচ্ছা করলে Netscape এর সর্বশেষ সংস্করণ তার FTP সাইট থেকে ডাউনলোড করতে পারেন। তবে Netscape চালানোর জন্য X Window থাকতে হবে। এখন FreeBSD'র জন্য Netscape এর একটি পৃথক সংস্করণ রয়েছে; তাই ডাউনলোডের পূর্বে এই সংস্করণটির কথা বিশেষভাবে মনে রাখবেন। ডাউনলোডের পর প্রথমে `gunzip filename` ও তারপর `tar xvf filename` কমান্ড লিখুন। এরপর বাইনারি ফাইলটিকে [.filename]#/usr/local/bin# অথবা সাধারণত বাইনারি ফাইল রাখা হয় এরকম কোন ডিরেক্টরিতে রাখুন, `rehash` কমান্ড দিন এবং তারপর প্রত্যেক ব্যবহারকারীর home ডিরেক্টরিস্থিত [.filename]#.cshrc# অথবা সমগ্র সিস্টেমের জন্য csh শেলের স্টার্টআপ ফাইল [.filename]#/etc/csh.cshrc#-এ নিচের লাইনগুলো লিখুনঃ

[.programlisting]
....
setenv XKEYSYMDB  /usr/X11R6/lib/X11/XKeysymDB
setenv XNLSPATH	 /usr/X11R6/lib/X11/nls
....

এখানে ধরে নেয়া হয়েছে যে [.filename]#XKeysymDB# ফাইল ও [.filename]#nls# ডিরেক্টরি উভয়ই [.filename]#/usr/X11R6/lib/X11# ডিরেক্টরিতে অবস্থিত। যদি এগুলো এই ডিরেক্টরিতে না থেকে তবে খুজে বের করে [.filename]#/usr/X11R6/lib/X11# ডিরেক্টরিতে কপি করে দিন।

ইতিপূর্বে যদি সিডিরম থেকে Netscape এর পোর্ট ইনস্টল করে থাকেন, তবে [.filename]#/usr/local/bin/netscape# এর স্থলে Netscape এর নতুন বাইনারি ফাইলটিকে রাখবেন না। [.filename]#/usr/local/bin/netscape# হল একটি শেল স্ক্রিপ্ট যা বেশ কিছু Environment Variable এর মান নির্ধারণ করে । বরং নতুন বাইনারি ফাইলটির নাম পরিবর্তন করে [.filename]#netscape.bin# রাখুন এবং পুরনো বাইনারি ফাইলটিকে সরিয়ে ফেলুন। পুরনো বাইনারি ফাইলটির নাম হল [.filename]#/usr/local/netscape/netscape# ।

[.title]
== কাজের পরিবেশ

শেল হল আপনার কাজের পরিবেশের সর্বাপেক্ষা গুরুত্বপূর্ণ অংশ। সাধারণত ডস-এ যে শেলটি ব্যবহৃত হয় তার নাম command.com । কমান্ড লাইনে যেসব কমান্ড লেখা হয়, শেল তা থেকে আপনি কি করতে চান তা বুঝতে পারে ও অপারেটিং সিস্টেমকে জানায়। এছাড়া শেলে ব্যবহারের জন্য শেল স্ক্রিপ্টও লেখা যায় যা অনেকটা ডস-এর ব্যাচ ফাইল এর মতই। শেল স্ক্রিপ্টে অনেকগুলো কমান্ড লেখা থাকে এবং ব্যবহারকারীর হস্তক্ষেপ ছাড়াই কমান্ডগুলো চালানো হয়।

FreeBSD'তে প্রথম থেকেই csh ও sh নামে দুটি শেল ইনস্টল করা থাকে। কমান্ড লাইন থেকে কাজকর্মের জন্য csh শেল ভাল, তবে শেল স্ক্রিপ্ট লেখা উচিত্‍ sh (বা bash) শেলের জন্য। এমুহূর্তে কি শেল ব্যবহার করছেন তা জানতে চাইলে `echo $SHELL` কমান্ডটি ব্যবহার করুন।

শেল হিসেবে csh বেশ ভাল কিন্তু tcsh শেল csh এর সব কাজই করতে পারে এবং এটির আরো কিছু অতিরিক্ত সুবিধা আছে। tcsh শেল ব্যবহার করলে kbd:[Arrow Key] চেপে পূর্বে ব্যবহৃত কমান্ডগুলো খুজে বের করা ও এডিট করা যায়। এই শেলে ফাইলের নামের প্রথম কিছু অংশ লিখে kbd:[tab] চাপলে (csh এর ক্ষেত্রে Esc) নামের অবশিষ্ট অংশ নিজে থেকেই লেখা হয়ে যায়। এছাড়া `cd -` লিখে সর্বশেষ ব্যবহৃত ডিরেক্টরিতে সরাসরি চলে যাওয়া যায়। এই শেলটির কমান্ড প্রম্পটকেও বেশ সহজেই পরিবর্তন করা যায়। সব মিলিয়ে tcsh শেলে কাজ করা বেশ সুবিধাজনক।

পরবর্তি তিনটি ধাপে একটি নতুন শেল ইনস্টল করার পদ্ধতি বর্ণিত হলঃ

. অন্যান্য সব পোর্ট বা প্যাকেজের মতই যে শেলটি ব্যবহার করতে চান তার পোর্ট বা প্যাকেজ ইনস্টল করুন। এখন প্রথমে `rehash` কমান্ড দিন ও পরে `which tcsh` (tcsh শেল ইনস্টলের ক্ষেত্রে) কমান্ড দিয়ে শেলটি আসলেই ইনস্টল হয়েছে কিনা তা নিশ্চিত হন । 
. root হিসেবে [.filename]#/etc/shells# ফাইলটি এডিট করুন। ফাইলের শেষে নতুন শেলটির জন্য একটি লাইন যোগ করুন, এক্ষেত্রে যা হল [.filename]#/usr/local/bin/tcsh# । এখন ফাইলটি সেভ করুন। (কিছু পোর্ট ইনস্টল হওয়ার সময় নিজে থেকেই এই পরিবর্তনগুলো সম্পন্ন হয়)
. স্থায়ীভাবে tcsh শেল ব্যবহার করতে চাইলে `chsh` কমান্ড ব্যবহার করুন। আর সাময়িকভাবে ব্যবহার করার ইচ্ছা থাকলে কমান্ড হিসেবে `tcsh` লিখুন। এর ফলে নতুন করে লগ ইন না করেই tcsh শেল ব্যবহার করতে পারবেন।

[.note]
====
[.admontitle]*Note:* +

বিভিন্ন ইউনিক্স বিশেষ করে FreeBSD'র পুরনো সংস্করণগুলোতে root এর শেল হিসেবে sh বা csh ব্যতীত অন্য কিছু ব্যবহারকরাটা বেশ বিপদজনক। কারণ অন্য কোন শেল ব্যবহার করলে, যখন single user mode এ কম্পিউটার ব্যবহারের প্রয়োজন হয়, তখন হয়তো কোন শেলই থাকবে না।দ্জতাই root এর শেল হিসেবে tcsh ব্যবহার করতে চাইলে `su -m` কমান্ড ব্যবহার করুন। এর ফলে tcsh শেল root এর Environment এর অংশ হয়ে যায়। আপনার home ডিরেক্টরির [.filename]#.tcshrc# ফাইলে alias রূপে এই লাইনটি ব্যবহার করে স্থায়ীভাবে এধরনের ব্যবস্থা করতে পারেন,

[.programlisting]
....
alias su su -m
....

====

tcsh শেল চালু হওয়ার সময় csh এর মতই [.filename]#/etc/csh.cshrc# ও [.filename]#/etc/csh.login# ফাইলদুটো পড়ে থাকে। যদি home ডিরেক্টরিতে কোন [.filename]#.tcshrc# ফাইল না থাকে তবে সেখানকার [.filename]#.login# ও [.filename]#.cshrc# ফাইলদুটোও tcsh পড়বে। [.filename]#.tcshrc# ফাইল তৈরীর একটি সহজ উপায় হল সরাসরি [.filename]#.cshrc#'কে [.filename]#.tcshrc#'তে কপি করা।

আপনার ব্যবহৃত শেলের প্রম্পট কিরকম দেখাবে, tcsh শেল ইনস্টলের পর আপনি এখন তা নির্ধারণ করতে পারেন। tcsh এর ম্যানুয়াল পেজে এসম্পর্কে বিস্তারিত বলা হয়েছে। এখানে প্রম্পট নির্ধারণের জন্য একটি লাইন উল্লেখ করা হল। [.filename]#.tcshrc# ফাইলে এই লাইনটি লিখলে প্রম্পট থেকে জানা যাবে - এ পর্যন্ত ব্যবহৃত কমান্ড, সময় ও বর্তমান ডিরেক্টরির নাম। এছাড়া tcsh শেল ব্যবহার করলে সবসময়ই প্রম্পটের শেষে root এর জন্য `#` এবং সাধারণ ব্যবহারকারীর জন্য `>` দেখা যাবে। লাইনটি হলঃ

[.programlisting]
....
set prompt "%h %t %~ %# "
....

যদি [.filename]#.tcshrc# ফাইলে কোন "set prompt" লাইন থাকে, তবে সেখানে এই লাইনটি লিখুন। আর যদি না থাকে, তবে "if($?prompt) then" এর নিচে লাইনটি যোগ করুন। পুরনো লাইন থাকলে তা _ comment out_ করে দিন। এর ফলে পুরনো লাইনটিকে সহজেই ভবিষ্যতে ব্যবহার করতে পারবেন। এই পরিবর্তনগুলো করার সময় উল্লেখিন space ও quote গুলো ব্যবহার করতে ভুলবেন না। `source .tcshrc` কমান্ড প্রয়োগ করলে শেল নতুন করে [.filename]#.tcshrc# ফাইলটি পড়বে।

সকল Environment Variable এর মান দেখতে হলে `env` কমান্ড ব্যবহার করুন। ফলস্বরূপ যে মানগুলো দেখতে পাবেন, তার মধ্যে উল্লেখযোগ্য হল ডিফল্ট এডিটর, পেজার, টার্মিনালের ধরন ইত্যাদি। যদি আপনি দূরবর্তী কোন কম্পিউটার থেকে লগ ইন করেন এবং টার্মিনালের অক্ষমতার কারণে কোন একটি প্রোগ্রাম চালাতে না পারেন, তবে খুবই কাজের একটি কমান্ড হল `setenv TERM vt100` ।

[.title]
== অন্যান্য

সিডিরম আনমাউন্ট করতে হলে root হিসেবে `/sbin/umount /cdrom` কমান্ড ব্যবহার করুন এবং সিডিরম বের করে নিন। আর সিডিরম মাউন্ট করার জন্য ট্রেতে ডিস্ক ভরে `/sbin/mount_cd9660 /dev/cd0a /cdrom` কমান্ড ব্যবহার করুন। এখানে  হল সিডিরম ড্রাইভের প্রতিনিধিত্বকারী ডিভাইস ফাইলের নাম। FreeBSD'র নতুন সংস্করণগুলোতে সিডিরম মাউন্ট করার জন্য শুধু `/sbin/mount /cdrom` লেখাই যথেষ্ট।

হার্ডডিস্কে স্থান সংকুলান না হলে live filesystem নামের FreeBSD'র দ্বিতীয় সিডিরমটি ব্যবহার করতে পারেন। Live filesystem এ কি থাকবে না থাকবে তা বিভিন্ন সংস্করণের ক্ষেত্রে বিভিন্ন হয়। আপনি হয়তো সিডিরম থেকে গেমস্‌ চালাতে পারেন। এজন্য অবশ্য `lndir` কমান্ড ব্যবহার করতে হবে যা X Window সিস্টেমের সাথে ইনস্টল হয়। সাধারণত ধরে নেয়া হয় যে প্রয়োজনীয় ফাইলগুলো [.filename]#/usr# ও তার বিভিন্ন সাবডিরেক্টরিতে থাকে। কিন্তু এক্ষেত্রে [.filename]#/cdrom# এর ভেতর ফাইলগুলো থাকায় `lndir` কমান্ড ব্যবহার করে বিভিন্ন প্রোগ্রামগুলোকে তাদের প্রয়োজনীয় ফাইলের প্রকৃত অবস্থান জানিয়ে দিতে হবে। ``lndir``-এর ব্যাপারে বিস্তারিত জানার জন্য `man lndir` কমান্ড দিয়ে `lndir` এর ম্যানুয়াল পেজ পড়ুন।

[.title]
== মন্তব্য

আপনি যদি এই গাইডটি পড়ে থাকেন তবে আমি জানতে খুবই আগ্রহী যে, লেখাটি কোথাও অস্পষ্ট মনে হয়েছে কিনা কিংবা কোন বিষয় বাদ পড়েছে বলে আপনার মনে হয় কিনা। লেখাটি আপনার উপকারে আসলে তাও জানাতে পারেন। পরিশেষে, চমত্‍কার পরামর্শের জন্য আমি বিশেষভাবে ধন্যবাদ জানাই, জন ফাইবার ও সানি-স্টোনি ব্রুক এর কম্পিউটার বিজ্ঞানের অধ্যাপক ইউজিন ডব্লিউ স্টার্ক কে।

অ্যানেলিসএন্ডারসন mailto:andrsnATandrsn.stanford.edu[andrsnATandrsn.stanford.edu]
